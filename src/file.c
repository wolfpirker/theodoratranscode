/* file.c generated by valac 0.18.1, the Vala compiler
 * generated from file.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>
#include <glib/gstdio.h>
#include <json-glib/json-glib.h>
// #include <json-glib/json-glib.h>
#include <float.h>
#include <math.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))

#define NS_FILE_TYPE_LOADING (ns_file_loading_get_type ())
#define NS_FILE_LOADING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), NS_FILE_TYPE_LOADING, NSFileLoading))
#define NS_FILE_LOADING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), NS_FILE_TYPE_LOADING, NSFileLoadingClass))
#define NS_FILE_IS_LOADING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NS_FILE_TYPE_LOADING))
#define NS_FILE_IS_LOADING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NS_FILE_TYPE_LOADING))
#define NS_FILE_LOADING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), NS_FILE_TYPE_LOADING, NSFileLoadingClass))

typedef struct _NSFileLoading NSFileLoading;
typedef struct _NSFileLoadingClass NSFileLoadingClass;
typedef struct _NSFileLoadingPrivate NSFileLoadingPrivate;
#define __vala_JsonObject_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonObject_free (var), NULL)))
typedef struct _Block5Data Block5Data;
#define __vala_JsonNode_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonNode_free (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

#define NS_FILE_TYPE_SAVING (ns_file_saving_get_type ())
#define NS_FILE_SAVING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), NS_FILE_TYPE_SAVING, NSFileSaving))
#define NS_FILE_SAVING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), NS_FILE_TYPE_SAVING, NSFileSavingClass))
#define NS_FILE_IS_SAVING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NS_FILE_TYPE_SAVING))
#define NS_FILE_IS_SAVING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NS_FILE_TYPE_SAVING))
#define NS_FILE_SAVING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), NS_FILE_TYPE_SAVING, NSFileSavingClass))

typedef struct _NSFileSaving NSFileSaving;
typedef struct _NSFileSavingClass NSFileSavingClass;
typedef struct _NSFileSavingPrivate NSFileSavingPrivate;

struct _NSFileLoading {
	GObject parent_instance;
	NSFileLoadingPrivate * priv;
};

struct _NSFileLoadingClass {
	GObjectClass parent_class;
};

struct _NSFileLoadingPrivate {
	JsonObject* _file_info;
	GList* _valuelist;
};

struct _Block5Data {
	int _ref_count_;
	NSFileLoading * self;
	guint8 i;
};

struct _NSFileSaving {
	GObject parent_instance;
	NSFileSavingPrivate * priv;
};

struct _NSFileSavingClass {
	GObjectClass parent_class;
};


static gpointer ns_file_loading_parent_class = NULL;
static gpointer ns_file_saving_parent_class = NULL;

GList* ns_file_dir (const gchar* path, gboolean relative_to_home, const gchar* prefix, const gchar* suffix);
static void _g_free0_ (gpointer var);
static void _g_list_free__g_free0_ (GList* self);
gint ns_file_cd (const gchar* new_path, gboolean relative_to_home);
GType ns_file_loading_get_type (void) G_GNUC_CONST;
#define NS_FILE_LOADING_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NS_FILE_TYPE_LOADING, NSFileLoadingPrivate))
enum  {
	NS_FILE_LOADING_DUMMY_PROPERTY,
	NS_FILE_LOADING_FILE_INFO,
	NS_FILE_LOADING_VALUELIST
};
static void _vala_JsonObject_free (JsonObject* self);
NSFileLoading* ns_file_loading_new (const gchar* file);
NSFileLoading* ns_file_loading_construct (GType object_type, const gchar* file);
static void ns_file_loading_get_json_object (NSFileLoading* self, const gchar* file);
static JsonObject* _vala_JsonObject_copy (JsonObject* self);
void ns_file_loading_create_valuelist (NSFileLoading* self, guint8 mode);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
static JsonNode* _vala_JsonNode_copy (JsonNode* self);
static void _vala_JsonNode_free (JsonNode* self);
static void ____lambda2_ (Block5Data* _data5_, JsonNode* node);
static void _____lambda2__gfunc (gconstpointer data, gpointer self);
JsonObject* ns_file_loading_get_file_info (NSFileLoading* self);
GList* ns_file_loading_get_valuelist (NSFileLoading* self);
static void ns_file_loading_finalize (GObject* obj);
static void _vala_ns_file_loading_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
GType ns_file_saving_get_type (void) G_GNUC_CONST;
enum  {
	NS_FILE_SAVING_DUMMY_PROPERTY
};
NSFileSaving* ns_file_saving_new (const gchar* filename);
NSFileSaving* ns_file_saving_construct (GType object_type, const gchar* filename);
JsonGenerator* ns_widgets_query_get_generator (void);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_list_free__g_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_free0_, NULL);
	g_list_free (self);
}


GList* ns_file_dir (const gchar* path, gboolean relative_to_home, const gchar* prefix, const gchar* suffix) {
	GList* result = NULL;
	GList* filename_list;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* complete_path;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (prefix != NULL, NULL);
	g_return_val_if_fail (suffix != NULL, NULL);
	filename_list = NULL;
	_tmp0_ = path;
	_tmp1_ = g_strdup (_tmp0_);
	complete_path = _tmp1_;
	{
		gboolean _tmp2_;
		const gchar* _tmp8_;
		GFile* _tmp9_ = NULL;
		GFile* directory;
		gchar* filename = NULL;
		GFile* _tmp10_;
		GFileEnumerator* _tmp11_ = NULL;
		GFileEnumerator* enumerator;
		GFileInfo* file_info = NULL;
		_tmp2_ = relative_to_home;
		if (_tmp2_ == TRUE) {
			const gchar* _tmp3_ = NULL;
			gchar* _tmp4_;
			gchar* home;
			const gchar* _tmp5_;
			const gchar* _tmp6_;
			gchar* _tmp7_;
			_tmp3_ = g_get_home_dir ();
			_tmp4_ = g_strdup (_tmp3_);
			home = _tmp4_;
			_tmp5_ = home;
			_tmp6_ = path;
			_tmp7_ = g_strconcat (_tmp5_, _tmp6_, NULL);
			_g_free0 (complete_path);
			complete_path = _tmp7_;
			_g_free0 (home);
		}
		_tmp8_ = complete_path;
		_tmp9_ = g_file_new_for_path (_tmp8_);
		directory = _tmp9_;
		_tmp10_ = directory;
		_tmp11_ = g_file_enumerate_children (_tmp10_, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error_);
		enumerator = _tmp11_;
		if (_inner_error_ != NULL) {
			_g_free0 (filename);
			_g_object_unref0 (directory);
			goto __catch5_g_error;
		}
		while (TRUE) {
			GFileEnumerator* _tmp12_;
			GFileInfo* _tmp13_ = NULL;
			GFileInfo* _tmp14_;
			GFileInfo* _tmp15_;
			GFileInfo* _tmp16_;
			const gchar* _tmp17_ = NULL;
			gchar* _tmp18_;
			const gchar* _tmp19_;
			const gchar* _tmp20_;
			gboolean _tmp21_ = FALSE;
			_tmp12_ = enumerator;
			_tmp13_ = g_file_enumerator_next_file (_tmp12_, NULL, &_inner_error_);
			_tmp14_ = _tmp13_;
			if (_inner_error_ != NULL) {
				_g_object_unref0 (file_info);
				_g_object_unref0 (enumerator);
				_g_free0 (filename);
				_g_object_unref0 (directory);
				goto __catch5_g_error;
			}
			_g_object_unref0 (file_info);
			file_info = _tmp14_;
			_tmp15_ = file_info;
			if (!(_tmp15_ != NULL)) {
				break;
			}
			_tmp16_ = file_info;
			_tmp17_ = g_file_info_get_name (_tmp16_);
			_tmp18_ = g_strdup (_tmp17_);
			_g_free0 (filename);
			filename = _tmp18_;
			_tmp19_ = filename;
			_tmp20_ = prefix;
			_tmp21_ = g_str_has_prefix (_tmp19_, _tmp20_);
			if (_tmp21_ == TRUE) {
				const gchar* _tmp22_;
				const gchar* _tmp23_;
				gboolean _tmp24_ = FALSE;
				_tmp22_ = filename;
				_tmp23_ = suffix;
				_tmp24_ = g_str_has_suffix (_tmp22_, _tmp23_);
				if (_tmp24_ == TRUE) {
					const gchar* _tmp25_;
					gchar* _tmp26_;
					_tmp25_ = filename;
					_tmp26_ = g_strdup (_tmp25_);
					filename_list = g_list_append (filename_list, _tmp26_);
				}
			}
		}
		_g_object_unref0 (file_info);
		_g_object_unref0 (enumerator);
		_g_free0 (filename);
		_g_object_unref0 (directory);
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		FILE* _tmp27_;
		GError* _tmp28_;
		const gchar* _tmp29_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp27_ = stderr;
		_tmp28_ = e;
		_tmp29_ = _tmp28_->message;
		fprintf (_tmp27_, "Error: %s\n", _tmp29_);
		_g_error_free0 (e);
	}
	__finally5:
	if (_inner_error_ != NULL) {
		_g_free0 (complete_path);
		__g_list_free__g_free0_0 (filename_list);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = filename_list;
	_g_free0 (complete_path);
	return result;
}


gint ns_file_cd (const gchar* new_path, gboolean relative_to_home) {
	gint result = 0;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* path;
	gboolean _tmp2_;
	const gchar* _tmp8_;
	gint _tmp9_ = 0;
	g_return_val_if_fail (new_path != NULL, 0);
	_tmp0_ = new_path;
	_tmp1_ = g_strdup (_tmp0_);
	path = _tmp1_;
	_tmp2_ = relative_to_home;
	if (_tmp2_ == TRUE) {
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		gchar* home;
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		_tmp3_ = g_get_home_dir ();
		_tmp4_ = g_strdup (_tmp3_);
		home = _tmp4_;
		_tmp5_ = home;
		_tmp6_ = new_path;
		_tmp7_ = g_strconcat (_tmp5_, _tmp6_, NULL);
		_g_free0 (path);
		path = _tmp7_;
		_g_free0 (home);
	}
	_tmp8_ = path;
	_tmp9_ = g_chdir (_tmp8_);
	if (_tmp9_ == (-1)) {
		const gchar* _tmp10_;
		gint _tmp11_ = 0;
		const gchar* _tmp13_;
		gint _tmp14_ = 0;
		_tmp10_ = path;
		_tmp11_ = g_mkdir_with_parents (_tmp10_, 0700);
		if (_tmp11_ == (-1)) {
			FILE* _tmp12_;
			_tmp12_ = stderr;
			fprintf (_tmp12_, "attempt to create directory failed!\n");
			result = -1;
			_g_free0 (path);
			return result;
		}
		_tmp13_ = path;
		_tmp14_ = g_chdir (_tmp13_);
		if (_tmp14_ == (-1)) {
			FILE* _tmp15_;
			_tmp15_ = stderr;
			fprintf (_tmp15_, "attempt to change directory failed!\n");
			result = -1;
			_g_free0 (path);
			return result;
		}
	}
	result = 0;
	_g_free0 (path);
	return result;
}


static void _vala_JsonObject_free (JsonObject* self) {
	g_boxed_free (json_object_get_type (), self);
}


NSFileLoading* ns_file_loading_construct (GType object_type, const gchar* file) {
	NSFileLoading * self = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (file != NULL, NULL);
	self = (NSFileLoading*) g_object_new (object_type, NULL);
	_tmp0_ = file;
	ns_file_loading_get_json_object (self, _tmp0_);
	return self;
}


NSFileLoading* ns_file_loading_new (const gchar* file) {
	return ns_file_loading_construct (NS_FILE_TYPE_LOADING, file);
}


static JsonObject* _vala_JsonObject_copy (JsonObject* self) {
	return g_boxed_copy (json_object_get_type (), self);
}


static gpointer __vala_JsonObject_copy0 (gpointer self) {
	return self ? _vala_JsonObject_copy (self) : NULL;
}


static void ns_file_loading_get_json_object (NSFileLoading* self, const gchar* file) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	{
		gsize length = 0UL;
		JsonParser* _tmp0_;
		JsonParser* parser;
		const gchar* _tmp1_;
		JsonNode* _tmp2_ = NULL;
		JsonObject* _tmp3_ = NULL;
		JsonObject* _tmp4_;
		_tmp0_ = json_parser_new ();
		parser = _tmp0_;
		_tmp1_ = file;
		json_parser_load_from_file (parser, _tmp1_, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (parser);
			goto __catch6_g_error;
		}
		_tmp2_ = json_parser_get_root (parser);
		_tmp3_ = json_node_get_object (_tmp2_);
		_tmp4_ = __vala_JsonObject_copy0 (_tmp3_);
		__vala_JsonObject_free0 (self->priv->_file_info);
		self->priv->_file_info = _tmp4_;
		_g_object_unref0 (parser);
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* e = NULL;
		FILE* _tmp5_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = stderr;
		fprintf (_tmp5_, "Error: Something in Loading went wrong...\n");
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static Block5Data* block5_data_ref (Block5Data* _data5_) {
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}


static void block5_data_unref (void * _userdata_) {
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		NSFileLoading * self;
		self = _data5_->self;
		_g_object_unref0 (self);
		g_slice_free (Block5Data, _data5_);
	}
}


static JsonNode* _vala_JsonNode_copy (JsonNode* self) {
	return g_boxed_copy (json_node_get_type (), self);
}


static gpointer __vala_JsonNode_copy0 (gpointer self) {
	return self ? _vala_JsonNode_copy (self) : NULL;
}


static void _vala_JsonNode_free (JsonNode* self) {
	g_boxed_free (json_node_get_type (), self);
}


static gchar* bool_to_string (gboolean self) {
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}


static gchar* double_to_string (gdouble self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}


static void ____lambda2_ (Block5Data* _data5_, JsonNode* node) {
	NSFileLoading * self;
	gchar* val;
	JsonNode* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	GQuark _tmp6_ = 0U;
	static GQuark _tmp5_label0 = 0;
	static GQuark _tmp5_label1 = 0;
	static GQuark _tmp5_label2 = 0;
	static GQuark _tmp5_label3 = 0;
	static GQuark _tmp5_label4 = 0;
	static GQuark _tmp5_label5 = 0;
	static GQuark _tmp5_label6 = 0;
	static GQuark _tmp5_label7 = 0;
	const gchar* _tmp21_;
	gchar* _tmp22_;
	guint8 _tmp23_;
	self = _data5_->self;
	g_return_if_fail (node != NULL);
	val = NULL;
	_tmp0_ = node;
	_tmp1_ = json_node_type_name (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (val);
	val = _tmp2_;
	_tmp3_ = val;
	_tmp4_ = _tmp3_;
	_tmp6_ = (NULL == _tmp4_) ? 0 : g_quark_from_string (_tmp4_);
	if ((_tmp6_ == ((0 != _tmp5_label0) ? _tmp5_label0 : (_tmp5_label0 = g_quark_from_static_string ("String")))) || (_tmp6_ == ((0 != _tmp5_label1) ? _tmp5_label1 : (_tmp5_label1 = g_quark_from_static_string ("gchararray"))))) {
		switch (0) {
			default:
			{
				JsonNode* _tmp7_;
				const gchar* _tmp8_ = NULL;
				gchar* _tmp9_;
				_tmp7_ = node;
				_tmp8_ = json_node_get_string (_tmp7_);
				_tmp9_ = g_strdup (_tmp8_);
				_g_free0 (val);
				val = _tmp9_;
				break;
			}
		}
	} else if ((_tmp6_ == ((0 != _tmp5_label2) ? _tmp5_label2 : (_tmp5_label2 = g_quark_from_static_string ("Boolean")))) || (_tmp6_ == ((0 != _tmp5_label3) ? _tmp5_label3 : (_tmp5_label3 = g_quark_from_static_string ("gboolean"))))) {
		switch (0) {
			default:
			{
				JsonNode* _tmp10_;
				gboolean _tmp11_ = FALSE;
				gchar* _tmp12_ = NULL;
				_tmp10_ = node;
				_tmp11_ = json_node_get_boolean (_tmp10_);
				_tmp12_ = bool_to_string (_tmp11_);
				_g_free0 (val);
				val = _tmp12_;
				break;
			}
		}
	} else if ((_tmp6_ == ((0 != _tmp5_label4) ? _tmp5_label4 : (_tmp5_label4 = g_quark_from_static_string ("Floating Point")))) || (_tmp6_ == ((0 != _tmp5_label5) ? _tmp5_label5 : (_tmp5_label5 = g_quark_from_static_string ("gdouble"))))) {
		switch (0) {
			default:
			{
				JsonNode* _tmp13_;
				gdouble _tmp14_ = 0.0;
				gchar* _tmp15_ = NULL;
				_tmp13_ = node;
				_tmp14_ = json_node_get_double (_tmp13_);
				_tmp15_ = double_to_string (_tmp14_);
				_g_free0 (val);
				val = _tmp15_;
				break;
			}
		}
	} else if ((_tmp6_ == ((0 != _tmp5_label6) ? _tmp5_label6 : (_tmp5_label6 = g_quark_from_static_string ("Integer")))) || (_tmp6_ == ((0 != _tmp5_label7) ? _tmp5_label7 : (_tmp5_label7 = g_quark_from_static_string ("gint64"))))) {
		switch (0) {
			default:
			{
				JsonNode* _tmp16_;
				gint64 _tmp17_ = 0LL;
				gchar* _tmp18_ = NULL;
				_tmp16_ = node;
				_tmp17_ = json_node_get_int (_tmp16_);
				_tmp18_ = g_strdup_printf ("%d", _tmp17_);
				_g_free0 (val);
				val = _tmp18_;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				FILE* _tmp19_;
				const gchar* _tmp20_;
				_tmp19_ = stdout;
				_tmp20_ = val;
				fprintf (_tmp19_, "type not in case: %s\n", _tmp20_);
				break;
			}
		}
	}
	_tmp21_ = val;
	_tmp22_ = g_strdup (_tmp21_);
	self->priv->_valuelist = g_list_append (self->priv->_valuelist, _tmp22_);
	_tmp23_ = _data5_->i;
	_data5_->i = _tmp23_ + 1;
	_g_free0 (val);
}


static void _____lambda2__gfunc (gconstpointer data, gpointer self) {
	____lambda2_ (self, data);
}


void ns_file_loading_create_valuelist (NSFileLoading* self, guint8 mode) {
	guint8 j;
	gchar** categories = NULL;
	gint categories_length1 = 0;
	gint _categories_size_ = 0;
	guint8 _tmp0_;
	gchar** _tmp17_;
	gint _tmp17__length1;
	g_return_if_fail (self != NULL);
	__g_list_free__g_free0_0 (self->priv->_valuelist);
	self->priv->_valuelist = NULL;
	j = (guint8) 0;
	_tmp0_ = mode;
	if (((gint) _tmp0_) == 0) {
		gchar* _tmp1_;
		gchar* _tmp2_;
		gchar* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar** _tmp6_ = NULL;
		_tmp1_ = g_strdup ("basics");
		_tmp2_ = g_strdup ("quality");
		_tmp3_ = g_strdup ("crop");
		_tmp4_ = g_strdup ("terminal");
		_tmp5_ = g_strdup ("color");
		_tmp6_ = g_new0 (gchar*, 5 + 1);
		_tmp6_[0] = _tmp1_;
		_tmp6_[1] = _tmp2_;
		_tmp6_[2] = _tmp3_;
		_tmp6_[3] = _tmp4_;
		_tmp6_[4] = _tmp5_;
		categories = (_vala_array_free (categories, categories_length1, (GDestroyNotify) g_free), NULL);
		categories = _tmp6_;
		categories_length1 = 5;
		_categories_size_ = categories_length1;
	} else {
		guint8 _tmp7_;
		_tmp7_ = mode;
		if (((gint) _tmp7_) == 1) {
			gchar* _tmp8_;
			gchar* _tmp9_;
			gchar* _tmp10_;
			gchar* _tmp11_;
			gchar** _tmp12_ = NULL;
			_tmp8_ = g_strdup ("color");
			_tmp9_ = g_strdup ("quality");
			_tmp10_ = g_strdup ("terminal");
			_tmp11_ = g_strdup ("crop");
			_tmp12_ = g_new0 (gchar*, 4 + 1);
			_tmp12_[0] = _tmp8_;
			_tmp12_[1] = _tmp9_;
			_tmp12_[2] = _tmp10_;
			_tmp12_[3] = _tmp11_;
			categories = (_vala_array_free (categories, categories_length1, (GDestroyNotify) g_free), NULL);
			categories = _tmp12_;
			categories_length1 = 4;
			_categories_size_ = categories_length1;
		} else {
			gchar* _tmp13_;
			gchar* _tmp14_;
			gchar* _tmp15_;
			gchar** _tmp16_ = NULL;
			_tmp13_ = g_strdup ("color");
			_tmp14_ = g_strdup ("quality");
			_tmp15_ = g_strdup ("terminal");
			_tmp16_ = g_new0 (gchar*, 3 + 1);
			_tmp16_[0] = _tmp13_;
			_tmp16_[1] = _tmp14_;
			_tmp16_[2] = _tmp15_;
			categories = (_vala_array_free (categories, categories_length1, (GDestroyNotify) g_free), NULL);
			categories = _tmp16_;
			categories_length1 = 3;
			_categories_size_ = categories_length1;
		}
	}
	_tmp17_ = categories;
	_tmp17__length1 = categories_length1;
	{
		gchar** category_collection = NULL;
		gint category_collection_length1 = 0;
		gint _category_collection_size_ = 0;
		gint category_it = 0;
		category_collection = _tmp17_;
		category_collection_length1 = _tmp17__length1;
		for (category_it = 0; category_it < _tmp17__length1; category_it = category_it + 1) {
			gchar* _tmp18_;
			gchar* category = NULL;
			_tmp18_ = g_strdup (category_collection[category_it]);
			category = _tmp18_;
			{
				Block5Data* _data5_;
				JsonNode* _tmp19_;
				JsonNode* node;
				JsonObject* _tmp20_;
				const gchar* _tmp21_;
				JsonNode* _tmp22_ = NULL;
				JsonNode* _tmp23_;
				JsonNode* _tmp24_;
				JsonObject* _tmp25_ = NULL;
				JsonObject* dup_object;
				JsonObject* _tmp26_;
				GList* _tmp27_ = NULL;
				GList* list;
				GList* _tmp28_;
				guint8 _tmp29_;
				_data5_ = g_slice_new0 (Block5Data);
				_data5_->_ref_count_ = 1;
				_data5_->self = g_object_ref (self);
				_tmp19_ = json_node_new (JSON_NODE_ARRAY);
				node = _tmp19_;
				_tmp20_ = self->priv->_file_info;
				_tmp21_ = category;
				_tmp22_ = json_object_get_member (_tmp20_, _tmp21_);
				_tmp23_ = __vala_JsonNode_copy0 (_tmp22_);
				__vala_JsonNode_free0 (node);
				node = _tmp23_;
				_tmp24_ = node;
				_tmp25_ = json_node_dup_object (_tmp24_);
				dup_object = _tmp25_;
				_tmp26_ = dup_object;
				_tmp27_ = json_object_get_values (_tmp26_);
				list = _tmp27_;
				_data5_->i = (guint8) 0;
				_tmp28_ = list;
				g_list_foreach (_tmp28_, _____lambda2__gfunc, _data5_);
				_tmp29_ = j;
				j = _tmp29_ + 1;
				_g_list_free0 (list);
				__vala_JsonObject_free0 (dup_object);
				__vala_JsonNode_free0 (node);
				_g_free0 (category);
				block5_data_unref (_data5_);
				_data5_ = NULL;
			}
		}
	}
	categories = (_vala_array_free (categories, categories_length1, (GDestroyNotify) g_free), NULL);
}


JsonObject* ns_file_loading_get_file_info (NSFileLoading* self) {
	JsonObject* result;
	JsonObject* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_file_info;
	result = _tmp0_;
	return result;
}


GList* ns_file_loading_get_valuelist (NSFileLoading* self) {
	GList* result;
	GList* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_valuelist;
	result = _tmp0_;
	return result;
}


static void ns_file_loading_class_init (NSFileLoadingClass * klass) {
	ns_file_loading_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (NSFileLoadingPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_ns_file_loading_get_property;
	G_OBJECT_CLASS (klass)->finalize = ns_file_loading_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), NS_FILE_LOADING_FILE_INFO, g_param_spec_boxed ("file-info", "file-info", "file-info", json_object_get_type (), G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), NS_FILE_LOADING_VALUELIST, g_param_spec_pointer ("valuelist", "valuelist", "valuelist", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void ns_file_loading_instance_init (NSFileLoading * self) {
	self->priv = NS_FILE_LOADING_GET_PRIVATE (self);
}


static void ns_file_loading_finalize (GObject* obj) {
	NSFileLoading * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, NS_FILE_TYPE_LOADING, NSFileLoading);
	__vala_JsonObject_free0 (self->priv->_file_info);
	__g_list_free__g_free0_0 (self->priv->_valuelist);
	G_OBJECT_CLASS (ns_file_loading_parent_class)->finalize (obj);
}


GType ns_file_loading_get_type (void) {
	static volatile gsize ns_file_loading_type_id__volatile = 0;
	if (g_once_init_enter (&ns_file_loading_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NSFileLoadingClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ns_file_loading_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NSFileLoading), 0, (GInstanceInitFunc) ns_file_loading_instance_init, NULL };
		GType ns_file_loading_type_id;
		ns_file_loading_type_id = g_type_register_static (G_TYPE_OBJECT, "NSFileLoading", &g_define_type_info, 0);
		g_once_init_leave (&ns_file_loading_type_id__volatile, ns_file_loading_type_id);
	}
	return ns_file_loading_type_id__volatile;
}


static void _vala_ns_file_loading_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	NSFileLoading * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, NS_FILE_TYPE_LOADING, NSFileLoading);
	switch (property_id) {
		case NS_FILE_LOADING_FILE_INFO:
		g_value_set_boxed (value, ns_file_loading_get_file_info (self));
		break;
		case NS_FILE_LOADING_VALUELIST:
		g_value_set_pointer (value, ns_file_loading_get_valuelist (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


NSFileSaving* ns_file_saving_construct (GType object_type, const gchar* filename) {
	NSFileSaving * self = NULL;
	gsize length = 0UL;
	JsonGenerator* _tmp0_;
	JsonGenerator* _tmp1_;
	gsize _tmp2_ = 0UL;
	gchar* _tmp3_ = NULL;
	gchar* output;
	const gchar* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	self = (NSFileSaving*) g_object_new (object_type, NULL);
	_tmp0_ = ns_widgets_query_get_generator ();
	_tmp1_ = _tmp0_;
	_tmp3_ = json_generator_to_data (_tmp1_, &_tmp2_);
	length = _tmp2_;
	output = _tmp3_;
	_tmp4_ = filename;
	g_file_set_contents (_tmp4_, output, (gssize) (-1), &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_free0 (output);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_g_free0 (output);
	return self;
}


NSFileSaving* ns_file_saving_new (const gchar* filename) {
	return ns_file_saving_construct (NS_FILE_TYPE_SAVING, filename);
}


static void ns_file_saving_class_init (NSFileSavingClass * klass) {
	ns_file_saving_parent_class = g_type_class_peek_parent (klass);
}


static void ns_file_saving_instance_init (NSFileSaving * self) {
}


GType ns_file_saving_get_type (void) {
	static volatile gsize ns_file_saving_type_id__volatile = 0;
	if (g_once_init_enter (&ns_file_saving_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NSFileSavingClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ns_file_saving_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NSFileSaving), 0, (GInstanceInitFunc) ns_file_saving_instance_init, NULL };
		GType ns_file_saving_type_id;
		ns_file_saving_type_id = g_type_register_static (G_TYPE_OBJECT, "NSFileSaving", &g_define_type_info, 0);
		g_once_init_leave (&ns_file_saving_type_id__volatile, ns_file_saving_type_id);
	}
	return ns_file_saving_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}




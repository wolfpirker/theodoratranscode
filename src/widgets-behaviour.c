/* widgets-behaviour.c generated by valac 0.18.1, the Vala compiler
 * generated from widgets-behaviour.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_MAIN (main_get_type ())
#define MAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN, Main))
#define MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN, MainClass))
#define IS_MAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN))
#define IS_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN))
#define MAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN, MainClass))

typedef struct _Main Main;
typedef struct _MainClass MainClass;
typedef struct _MainPrivate MainPrivate;

#define NS_WIDGETS_TYPE_BEHAVIOUR (ns_widgets_behaviour_get_type ())
#define NS_WIDGETS_BEHAVIOUR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), NS_WIDGETS_TYPE_BEHAVIOUR, NSWidgetsBehaviour))
#define NS_WIDGETS_BEHAVIOUR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), NS_WIDGETS_TYPE_BEHAVIOUR, NSWidgetsBehaviourClass))
#define NS_WIDGETS_IS_BEHAVIOUR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NS_WIDGETS_TYPE_BEHAVIOUR))
#define NS_WIDGETS_IS_BEHAVIOUR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NS_WIDGETS_TYPE_BEHAVIOUR))
#define NS_WIDGETS_BEHAVIOUR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), NS_WIDGETS_TYPE_BEHAVIOUR, NSWidgetsBehaviourClass))

typedef struct _NSWidgetsBehaviour NSWidgetsBehaviour;
typedef struct _NSWidgetsBehaviourClass NSWidgetsBehaviourClass;
typedef struct _NSWidgetsBehaviourPrivate NSWidgetsBehaviourPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _Main {
	GtkApplication parent_instance;
	MainPrivate * priv;
	GtkBuilder* builder;
	GtkLabel* advice_label;
	GtkInfoBar* infobar;
	GtkInfoBar* error_infbar;
	GtkLabel* lbl_video;
	GtkLabel* lbl_audio;
	GtkLabel* lbl_other;
};

struct _MainClass {
	GtkApplicationClass parent_class;
};

struct _NSWidgetsBehaviour {
	Main parent_instance;
	NSWidgetsBehaviourPrivate * priv;
};

struct _NSWidgetsBehaviourClass {
	MainClass parent_class;
};


static gpointer ns_widgets_behaviour_parent_class = NULL;

GType main_get_type (void) G_GNUC_CONST;
GType ns_widgets_behaviour_get_type (void) G_GNUC_CONST;
enum  {
	NS_WIDGETS_BEHAVIOUR_DUMMY_PROPERTY
};
NSWidgetsBehaviour* ns_widgets_behaviour_new (void);
NSWidgetsBehaviour* ns_widgets_behaviour_construct (GType object_type);
Main* main_new (void);
Main* main_construct (GType object_type);
void on_sbtn_time_changed (GtkSpinButton* sbtn, GtkEntry* entry, NSWidgetsBehaviour* self);
void on_fbtn_basics1_file_set (GtkFileChooserButton* fbtn, GtkRadioButton* rbtn, NSWidgetsBehaviour* self);
void on_adjust_quality_value_changed_unset (GtkAdjustment* adjust, GtkCheckButton* cbtn, NSWidgetsBehaviour* self);
void on_adjust_quality_value_changed_set (GtkAdjustment* adjust, GtkCheckButton* cbtn, NSWidgetsBehaviour* self);
void on_cbtn_quality0_toggled (GtkToggleButton* cbtn, GtkCheckButton* cbtn_2pass, NSWidgetsBehaviour* self);
void on_scale_quality4_value_changed (GtkSpinButton* sbtn, GtkGrid* grid, NSWidgetsBehaviour* self);
gint ns_widgets_feedback_get_width (void);
gint ns_widgets_feedback_get_height (void);
void on_scale_scale_value_changed (GtkScale* scale, GtkGrid* grid, NSWidgetsBehaviour* self);
void on_rbtn_basics_toggled (GtkToggleButton* sender, NSWidgetsBehaviour* self);
void main_set_active_tab (Main* self, const gchar* value);
static void ns_widgets_behaviour_hide_infoboxes (NSWidgetsBehaviour* self);
void on_rbtn_quality_toggled (GtkToggleButton* sender, NSWidgetsBehaviour* self);
void on_rbtn_crop_toggled (GtkToggleButton* sender, NSWidgetsBehaviour* self);
void on_rbtn_other_toggled (GtkToggleButton* sender, NSWidgetsBehaviour* self);
void on_btn_f2theora_close_clicked (GtkWidget* sender, NSWidgetsBehaviour* self);
const gchar* main_get_active_tab (Main* self);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


NSWidgetsBehaviour* ns_widgets_behaviour_construct (GType object_type) {
	NSWidgetsBehaviour * self = NULL;
	self = (NSWidgetsBehaviour*) main_construct (object_type);
	return self;
}


NSWidgetsBehaviour* ns_widgets_behaviour_new (void) {
	return ns_widgets_behaviour_construct (NS_WIDGETS_TYPE_BEHAVIOUR);
}


void on_sbtn_time_changed (GtkSpinButton* sbtn, GtkEntry* entry, NSWidgetsBehaviour* self) {
	GtkSpinButton* _tmp0_;
	gint _tmp1_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sbtn != NULL);
	g_return_if_fail (entry != NULL);
	_tmp0_ = sbtn;
	_tmp1_ = gtk_spin_button_get_value_as_int (_tmp0_);
	if (60 <= _tmp1_) {
		gint minutes = 0;
		GtkSpinButton* _tmp2_;
		GtkEntry* _tmp3_;
		const gchar* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		GtkEntry* _tmp6_;
		gint _tmp7_;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		_tmp2_ = sbtn;
		gtk_spin_button_set_value (_tmp2_, (gdouble) 0);
		_tmp3_ = entry;
		_tmp4_ = gtk_entry_get_text (_tmp3_);
		_tmp5_ = atoi (_tmp4_);
		minutes = _tmp5_ + 1;
		_tmp6_ = entry;
		_tmp7_ = minutes;
		_tmp8_ = g_strdup_printf ("%d", _tmp7_);
		_tmp9_ = _tmp8_;
		gtk_entry_set_text (_tmp6_, _tmp9_);
		_g_free0 (_tmp9_);
	} else {
		GtkSpinButton* _tmp10_;
		gint _tmp11_ = 0;
		_tmp10_ = sbtn;
		_tmp11_ = gtk_spin_button_get_value_as_int (_tmp10_);
		if (0 > _tmp11_) {
			gint minutes = 0;
			GtkSpinButton* _tmp12_;
			GtkEntry* _tmp13_;
			const gchar* _tmp14_ = NULL;
			gint _tmp15_ = 0;
			gint _tmp16_;
			GtkEntry* _tmp17_;
			gint _tmp18_;
			gchar* _tmp19_ = NULL;
			gchar* _tmp20_;
			_tmp12_ = sbtn;
			gtk_spin_button_set_value (_tmp12_, (gdouble) 59);
			_tmp13_ = entry;
			_tmp14_ = gtk_entry_get_text (_tmp13_);
			_tmp15_ = atoi (_tmp14_);
			minutes = _tmp15_ - 1;
			_tmp16_ = minutes;
			if (0 > _tmp16_) {
				minutes = 0;
			}
			_tmp17_ = entry;
			_tmp18_ = minutes;
			_tmp19_ = g_strdup_printf ("%d", _tmp18_);
			_tmp20_ = _tmp19_;
			gtk_entry_set_text (_tmp17_, _tmp20_);
			_g_free0 (_tmp20_);
		}
	}
}


void on_fbtn_basics1_file_set (GtkFileChooserButton* fbtn, GtkRadioButton* rbtn, NSWidgetsBehaviour* self) {
	GtkRadioButton* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (fbtn != NULL);
	g_return_if_fail (rbtn != NULL);
	_tmp0_ = rbtn;
	gtk_toggle_button_set_active ((GtkToggleButton*) _tmp0_, TRUE);
}


void on_adjust_quality_value_changed_unset (GtkAdjustment* adjust, GtkCheckButton* cbtn, NSWidgetsBehaviour* self) {
	GtkCheckButton* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (adjust != NULL);
	g_return_if_fail (cbtn != NULL);
	_tmp0_ = cbtn;
	gtk_toggle_button_set_active ((GtkToggleButton*) _tmp0_, FALSE);
}


void on_adjust_quality_value_changed_set (GtkAdjustment* adjust, GtkCheckButton* cbtn, NSWidgetsBehaviour* self) {
	GtkCheckButton* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (adjust != NULL);
	g_return_if_fail (cbtn != NULL);
	_tmp0_ = cbtn;
	gtk_toggle_button_set_active ((GtkToggleButton*) _tmp0_, TRUE);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void on_cbtn_quality0_toggled (GtkToggleButton* cbtn, GtkCheckButton* cbtn_2pass, NSWidgetsBehaviour* self) {
	GtkToggleButton* _tmp0_;
	GtkWidget* _tmp1_ = NULL;
	GtkGrid* _tmp2_;
	GtkGrid* quality_grid;
	GtkGrid* _tmp3_;
	GtkWidget* _tmp4_ = NULL;
	GtkCheckButton* _tmp5_;
	GtkCheckButton* cbtn_soft_target;
	GtkToggleButton* _tmp6_;
	gboolean _tmp7_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cbtn != NULL);
	g_return_if_fail (cbtn_2pass != NULL);
	_tmp0_ = cbtn;
	_tmp1_ = gtk_widget_get_parent ((GtkWidget*) _tmp0_);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, GTK_TYPE_GRID) ? ((GtkGrid*) _tmp1_) : NULL);
	quality_grid = _tmp2_;
	_tmp3_ = quality_grid;
	_tmp4_ = gtk_grid_get_child_at (_tmp3_, 1, 7);
	_tmp5_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, GTK_TYPE_CHECK_BUTTON) ? ((GtkCheckButton*) _tmp4_) : NULL);
	cbtn_soft_target = _tmp5_;
	_tmp6_ = cbtn;
	_tmp7_ = gtk_toggle_button_get_active (_tmp6_);
	if (_tmp7_ == TRUE) {
		GtkCheckButton* _tmp8_;
		GtkCheckButton* _tmp9_;
		GtkCheckButton* _tmp10_;
		_tmp8_ = cbtn_2pass;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp8_, TRUE);
		_tmp9_ = cbtn_soft_target;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp9_, TRUE);
		_tmp10_ = cbtn_soft_target;
		gtk_toggle_button_set_active ((GtkToggleButton*) _tmp10_, TRUE);
	} else {
		GtkCheckButton* _tmp11_;
		GtkCheckButton* _tmp12_;
		GtkCheckButton* _tmp13_;
		GtkCheckButton* _tmp14_;
		_tmp11_ = cbtn_2pass;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp11_, FALSE);
		_tmp12_ = cbtn_2pass;
		gtk_toggle_button_set_active ((GtkToggleButton*) _tmp12_, FALSE);
		_tmp13_ = cbtn_soft_target;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp13_, FALSE);
		_tmp14_ = cbtn_soft_target;
		gtk_toggle_button_set_active ((GtkToggleButton*) _tmp14_, FALSE);
	}
	_g_object_unref0 (cbtn_soft_target);
	_g_object_unref0 (quality_grid);
}


static gdouble double_parse (const gchar* str) {
	gdouble result = 0.0;
	const gchar* _tmp0_;
	gdouble _tmp1_ = 0.0;
	g_return_val_if_fail (str != NULL, 0.0);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtod (_tmp0_, NULL);
	result = _tmp1_;
	return result;
}


void on_scale_quality4_value_changed (GtkSpinButton* sbtn, GtkGrid* grid, NSWidgetsBehaviour* self) {
	GtkGrid* _tmp0_;
	GtkWidget* _tmp1_ = NULL;
	GtkEntry* _tmp2_;
	GtkEntry* entry;
	GtkSpinButton* _tmp3_;
	GtkAdjustment* _tmp4_ = NULL;
	GtkAdjustment* _tmp5_;
	GtkAdjustment* adjust;
	GtkSpinButton* _tmp6_;
	gint _tmp7_ = 0;
	gint height;
	gint new_width = 0;
	gint _tmp8_;
	gint _tmp9_;
	GtkEntry* _tmp36_;
	gint _tmp37_;
	gchar* _tmp38_ = NULL;
	gchar* _tmp39_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sbtn != NULL);
	g_return_if_fail (grid != NULL);
	_tmp0_ = grid;
	_tmp1_ = gtk_grid_get_child_at (_tmp0_, 0, 1);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, GTK_TYPE_ENTRY) ? ((GtkEntry*) _tmp1_) : NULL);
	entry = _tmp2_;
	_tmp3_ = sbtn;
	_tmp4_ = gtk_spin_button_get_adjustment (_tmp3_);
	_tmp5_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, GTK_TYPE_ADJUSTMENT) ? ((GtkAdjustment*) _tmp4_) : NULL);
	adjust = _tmp5_;
	_tmp6_ = sbtn;
	_tmp7_ = gtk_spin_button_get_value_as_int (_tmp6_);
	height = _tmp7_;
	_tmp8_ = ns_widgets_feedback_get_width ();
	_tmp9_ = _tmp8_;
	if (_tmp9_ != 0) {
		GtkGrid* _tmp10_;
		GtkWidget* _tmp11_ = NULL;
		GtkScale* _tmp12_;
		GtkScale* scale_scale;
		gint _tmp13_;
		gint _tmp14_;
		gint _tmp15_;
		gint _tmp16_;
		gint _tmp17_;
		gint _tmp18_;
		GtkScale* _tmp20_;
		gboolean _tmp21_ = FALSE;
		gboolean _tmp22_;
		_tmp10_ = grid;
		_tmp11_ = gtk_grid_get_child_at (_tmp10_, 0, 0);
		_tmp12_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp11_, GTK_TYPE_SCALE) ? ((GtkScale*) _tmp11_) : NULL);
		scale_scale = _tmp12_;
		_tmp13_ = ns_widgets_feedback_get_width ();
		_tmp14_ = _tmp13_;
		_tmp15_ = height;
		_tmp16_ = ns_widgets_feedback_get_height ();
		_tmp17_ = _tmp16_;
		new_width = (_tmp14_ * _tmp15_) / _tmp17_;
		_tmp18_ = new_width;
		if ((_tmp18_ % 2) == 1) {
			gint _tmp19_;
			_tmp19_ = new_width;
			new_width = _tmp19_ - 1;
		}
		_tmp20_ = scale_scale;
		g_object_get ((GtkWidget*) _tmp20_, "has-focus", &_tmp21_, NULL);
		_tmp22_ = _tmp21_;
		if (_tmp22_ == FALSE) {
			GtkScale* _tmp23_;
			GtkAdjustment* _tmp24_ = NULL;
			GtkAdjustment* _tmp25_;
			GtkAdjustment* adjust_scale;
			gint _tmp26_;
			gint _tmp27_;
			gint source_height;
			gint _tmp28_;
			gint _tmp29_;
			gint new_val;
			GtkAdjustment* _tmp30_;
			gint _tmp31_;
			gchar* _tmp32_ = NULL;
			gchar* _tmp33_;
			gdouble _tmp34_ = 0.0;
			_tmp23_ = scale_scale;
			_tmp24_ = gtk_range_get_adjustment ((GtkRange*) _tmp23_);
			_tmp25_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp24_, GTK_TYPE_ADJUSTMENT) ? ((GtkAdjustment*) _tmp24_) : NULL);
			adjust_scale = _tmp25_;
			_tmp26_ = ns_widgets_feedback_get_height ();
			_tmp27_ = _tmp26_;
			source_height = _tmp27_;
			_tmp28_ = height;
			_tmp29_ = source_height;
			new_val = (1000 * _tmp28_) / _tmp29_;
			_tmp30_ = adjust_scale;
			_tmp31_ = new_val;
			_tmp32_ = g_strdup_printf ("%d", _tmp31_);
			_tmp33_ = _tmp32_;
			_tmp34_ = double_parse (_tmp33_);
			gtk_adjustment_set_value (_tmp30_, _tmp34_ / 1000);
			_g_free0 (_tmp33_);
			_g_object_unref0 (adjust_scale);
		}
		_g_object_unref0 (scale_scale);
	} else {
		gint _tmp35_;
		_tmp35_ = height;
		new_width = (_tmp35_ * 16) / 9;
	}
	_tmp36_ = entry;
	_tmp37_ = new_width;
	_tmp38_ = g_strdup_printf ("%d", _tmp37_);
	_tmp39_ = _tmp38_;
	gtk_entry_set_text (_tmp36_, _tmp39_);
	_g_free0 (_tmp39_);
	_g_object_unref0 (adjust);
	_g_object_unref0 (entry);
}


static gchar* double_to_string (gdouble self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}


void on_scale_scale_value_changed (GtkScale* scale, GtkGrid* grid, NSWidgetsBehaviour* self) {
	GtkScale* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (scale != NULL);
	g_return_if_fail (grid != NULL);
	_tmp0_ = scale;
	g_object_get ((GtkWidget*) _tmp0_, "has-focus", &_tmp1_, NULL);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == FALSE) {
		return;
	}
	_tmp3_ = ns_widgets_feedback_get_width ();
	_tmp4_ = _tmp3_;
	if (_tmp4_ != 0) {
		gint _tmp5_;
		gint _tmp6_;
		gint width;
		gint _tmp7_;
		gint _tmp8_;
		gint height;
		GtkScale* _tmp9_;
		gdouble _tmp10_ = 0.0;
		gchar* _tmp11_ = NULL;
		gchar* info;
		const gchar* _tmp12_;
		gint _tmp13_ = 0;
		gint share;
		gint _tmp14_;
		gint _tmp15_;
		gint _tmp16_;
		gint _tmp17_;
		gint _tmp18_;
		gint _tmp20_;
		GtkGrid* _tmp22_;
		GtkWidget* _tmp23_ = NULL;
		GtkEntry* _tmp24_;
		GtkEntry* width_e;
		GtkGrid* _tmp25_;
		GtkWidget* _tmp26_ = NULL;
		GtkSpinButton* _tmp27_;
		GtkSpinButton* height_sbtn;
		GtkEntry* _tmp28_;
		gint _tmp29_;
		gchar* _tmp30_ = NULL;
		gchar* _tmp31_;
		GtkSpinButton* _tmp32_;
		gint _tmp33_;
		gchar* _tmp34_ = NULL;
		gchar* _tmp35_;
		_tmp5_ = ns_widgets_feedback_get_width ();
		_tmp6_ = _tmp5_;
		width = _tmp6_;
		_tmp7_ = ns_widgets_feedback_get_height ();
		_tmp8_ = _tmp7_;
		height = _tmp8_;
		_tmp9_ = scale;
		_tmp10_ = gtk_range_get_value ((GtkRange*) _tmp9_);
		_tmp11_ = double_to_string (_tmp10_ * 1000);
		info = _tmp11_;
		_tmp12_ = info;
		_tmp13_ = atoi (_tmp12_);
		share = _tmp13_;
		_tmp14_ = width;
		_tmp15_ = share;
		width = (_tmp14_ * _tmp15_) / 1000;
		_tmp16_ = height;
		_tmp17_ = share;
		height = (_tmp16_ * _tmp17_) / 1000;
		_tmp18_ = width;
		if ((_tmp18_ % 2) == 1) {
			gint _tmp19_;
			_tmp19_ = width;
			width = _tmp19_ - 1;
		}
		_tmp20_ = height;
		if ((_tmp20_ % 2) == 1) {
			gint _tmp21_;
			_tmp21_ = height;
			height = _tmp21_ - 1;
		}
		_tmp22_ = grid;
		_tmp23_ = gtk_grid_get_child_at (_tmp22_, 0, 1);
		_tmp24_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp23_, GTK_TYPE_ENTRY) ? ((GtkEntry*) _tmp23_) : NULL);
		width_e = _tmp24_;
		_tmp25_ = grid;
		_tmp26_ = gtk_grid_get_child_at (_tmp25_, 1, 1);
		_tmp27_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp26_, GTK_TYPE_SPIN_BUTTON) ? ((GtkSpinButton*) _tmp26_) : NULL);
		height_sbtn = _tmp27_;
		_tmp28_ = width_e;
		_tmp29_ = width;
		_tmp30_ = g_strdup_printf ("%d", _tmp29_);
		_tmp31_ = _tmp30_;
		gtk_entry_set_text (_tmp28_, _tmp31_);
		_g_free0 (_tmp31_);
		_tmp32_ = height_sbtn;
		_tmp33_ = height;
		_tmp34_ = g_strdup_printf ("%d", _tmp33_);
		_tmp35_ = _tmp34_;
		gtk_entry_set_text ((GtkEntry*) _tmp32_, _tmp35_);
		_g_free0 (_tmp35_);
		_g_object_unref0 (height_sbtn);
		_g_object_unref0 (width_e);
		_g_free0 (info);
	}
}


void on_rbtn_basics_toggled (GtkToggleButton* sender, NSWidgetsBehaviour* self) {
	GtkBuilder* _tmp0_;
	GObject* _tmp1_ = NULL;
	GtkWidget* _tmp2_;
	GtkWidget* ibar;
	GtkLabel* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = ((Main*) self)->builder;
	_tmp1_ = gtk_builder_get_object (_tmp0_, "infbar_basics");
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp1_) : NULL);
	ibar = _tmp2_;
	main_set_active_tab ((Main*) self, "basics");
	ns_widgets_behaviour_hide_infoboxes (self);
	gtk_widget_show (ibar);
	_tmp3_ = ((Main*) self)->advice_label;
	gtk_label_set_text (_tmp3_, "In case a filename is entered as target, the file will " "be stored in your user home directory.\n\n" "Tips on Subtitle section\n" "if you want to specify more than one subtitle, " "you can do this via Other→parameters.\n" "if you leave the encoding field blank, UTF-8 will be " "used, which works in most cases.\n" "For a list of supported encodings you can use the " "'iconv -l' command.\n.");
	_g_object_unref0 (ibar);
}


void on_rbtn_quality_toggled (GtkToggleButton* sender, NSWidgetsBehaviour* self) {
	GtkBuilder* _tmp0_;
	GObject* _tmp1_ = NULL;
	GtkWidget* _tmp2_;
	GtkWidget* ibar;
	GtkLabel* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = ((Main*) self)->builder;
	_tmp1_ = gtk_builder_get_object (_tmp0_, "infbar_quality");
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp1_) : NULL);
	ibar = _tmp2_;
	main_set_active_tab ((Main*) self, "quality");
	ns_widgets_behaviour_hide_infoboxes (self);
	gtk_widget_show (ibar);
	_tmp3_ = ((Main*) self)->advice_label;
	gtk_label_set_text (_tmp3_, "* the video qualifier: use higher values for better quality (default: " \
"6)\n" "* the audio qualifier: use higher value for better quality (default: 1" \
")\n" "* as alternative to the qualifiers, it is possible to set a bitrate.\n" "optimize: makes the quality/filesize ratio better, " "but is a bit slower.\n" "soft-target and two-pass can be enabled if a Video Bitrate is specifie" \
"d.\n" "soft-target: less strict rate control, but with otherwise higher quali" \
"ty.\n" "two-pass: slower conversion, but with higher quality.");
	_g_object_unref0 (ibar);
}


void on_rbtn_crop_toggled (GtkToggleButton* sender, NSWidgetsBehaviour* self) {
	GtkBuilder* _tmp0_;
	GObject* _tmp1_ = NULL;
	GtkWidget* _tmp2_;
	GtkWidget* ibar;
	GtkLabel* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = ((Main*) self)->builder;
	_tmp1_ = gtk_builder_get_object (_tmp0_, "infbar_crop");
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp1_) : NULL);
	ibar = _tmp2_;
	main_set_active_tab ((Main*) self, "crop");
	ns_widgets_behaviour_hide_infoboxes (self);
	gtk_widget_show (ibar);
	_tmp3_ = ((Main*) self)->advice_label;
	gtk_label_set_text (_tmp3_, "About the preview possiblity\n" "After a click on preview the file preview.ogv is saved \n" "in the directory for temporary files (likely /tmp/).\n" "With Fast preview enabled the preview will result " "in worse\nquality and/or higher bitrate than otherwise.\n");
	_g_object_unref0 (ibar);
}


void on_rbtn_other_toggled (GtkToggleButton* sender, NSWidgetsBehaviour* self) {
	GtkBuilder* _tmp0_;
	GObject* _tmp1_ = NULL;
	GtkWidget* _tmp2_;
	GtkWidget* ibar;
	GtkBuilder* _tmp3_;
	GObject* _tmp4_ = NULL;
	GtkWidget* _tmp5_;
	GtkWidget* ibar2;
	GtkBuilder* _tmp6_;
	GObject* _tmp7_ = NULL;
	GtkWidget* _tmp8_;
	GtkWidget* ibar3;
	GtkLabel* _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = ((Main*) self)->builder;
	_tmp1_ = gtk_builder_get_object (_tmp0_, "infbar_color");
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp1_) : NULL);
	ibar = _tmp2_;
	_tmp3_ = ((Main*) self)->builder;
	_tmp4_ = gtk_builder_get_object (_tmp3_, "infbar_terminal");
	_tmp5_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp4_) : NULL);
	ibar2 = _tmp5_;
	_tmp6_ = ((Main*) self)->builder;
	_tmp7_ = gtk_builder_get_object (_tmp6_, "infbar_profiles");
	_tmp8_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp7_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp7_) : NULL);
	ibar3 = _tmp8_;
	main_set_active_tab ((Main*) self, "other");
	ns_widgets_behaviour_hide_infoboxes (self);
	gtk_widget_show (ibar);
	gtk_widget_show (ibar2);
	gtk_widget_show (ibar3);
	_tmp9_ = ((Main*) self)->advice_label;
	gtk_label_set_text (_tmp9_, "Contrast, Gamma and Saturation have a default value " "of 1.0.\n" "lower values in the color settings make the video darker" " or in case of\nsaturation greyer.\n" "For a list of parameters you can click on the button " "ffmpeg2theora help.");
	_g_object_unref0 (ibar3);
	_g_object_unref0 (ibar2);
	_g_object_unref0 (ibar);
}


static void ns_widgets_behaviour_hide_infoboxes (NSWidgetsBehaviour* self) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar** _tmp7_ = NULL;
	gchar** categories;
	gint categories_length1;
	gint _categories_size_;
	gchar** _tmp8_;
	gint _tmp8__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("infbar_basics");
	_tmp1_ = g_strdup ("infbar_quality");
	_tmp2_ = g_strdup ("infbar_crop");
	_tmp3_ = g_strdup ("infbar_color");
	_tmp4_ = g_strdup ("infbar_terminal");
	_tmp5_ = g_strdup ("infbar_profiles");
	_tmp6_ = g_strdup ("infbar_f2theora_help");
	_tmp7_ = g_new0 (gchar*, 7 + 1);
	_tmp7_[0] = _tmp0_;
	_tmp7_[1] = _tmp1_;
	_tmp7_[2] = _tmp2_;
	_tmp7_[3] = _tmp3_;
	_tmp7_[4] = _tmp4_;
	_tmp7_[5] = _tmp5_;
	_tmp7_[6] = _tmp6_;
	categories = _tmp7_;
	categories_length1 = 7;
	_categories_size_ = categories_length1;
	_tmp8_ = categories;
	_tmp8__length1 = categories_length1;
	{
		gchar** infobox_collection = NULL;
		gint infobox_collection_length1 = 0;
		gint _infobox_collection_size_ = 0;
		gint infobox_it = 0;
		infobox_collection = _tmp8_;
		infobox_collection_length1 = _tmp8__length1;
		for (infobox_it = 0; infobox_it < _tmp8__length1; infobox_it = infobox_it + 1) {
			gchar* _tmp9_;
			gchar* infobox = NULL;
			_tmp9_ = g_strdup (infobox_collection[infobox_it]);
			infobox = _tmp9_;
			{
				GtkBuilder* _tmp10_;
				const gchar* _tmp11_;
				GObject* _tmp12_ = NULL;
				GtkWidget* _tmp13_;
				GtkWidget* ibar;
				GtkWidget* _tmp14_;
				_tmp10_ = ((Main*) self)->builder;
				_tmp11_ = infobox;
				_tmp12_ = gtk_builder_get_object (_tmp10_, _tmp11_);
				_tmp13_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp12_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp12_) : NULL);
				ibar = _tmp13_;
				_tmp14_ = ibar;
				gtk_widget_hide (_tmp14_);
				_g_object_unref0 (ibar);
				_g_free0 (infobox);
			}
		}
	}
	categories = (_vala_array_free (categories, categories_length1, (GDestroyNotify) g_free), NULL);
}


void on_btn_f2theora_close_clicked (GtkWidget* sender, NSWidgetsBehaviour* self) {
	GtkBuilder* _tmp0_;
	GObject* _tmp1_ = NULL;
	GtkWidget* _tmp2_;
	GtkWidget* infbar_f2theora;
	GtkBuilder* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	GObject* _tmp8_ = NULL;
	GtkWidget* _tmp9_;
	GtkWidget* _tmp10_;
	GtkWidget* current_tab_infbar;
	GtkWidget* _tmp11_;
	GtkWidget* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp14_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = ((Main*) self)->builder;
	_tmp1_ = gtk_builder_get_object (_tmp0_, "infbar_f2theora_help");
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp1_) : NULL);
	infbar_f2theora = _tmp2_;
	_tmp3_ = ((Main*) self)->builder;
	_tmp4_ = main_get_active_tab ((Main*) self);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat ("infbar_", _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = gtk_builder_get_object (_tmp3_, _tmp7_);
	_tmp9_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp8_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp8_) : NULL);
	_tmp10_ = _tmp9_;
	_g_free0 (_tmp7_);
	current_tab_infbar = _tmp10_;
	_tmp11_ = infbar_f2theora;
	gtk_widget_hide (_tmp11_);
	_tmp12_ = current_tab_infbar;
	gtk_widget_show (_tmp12_);
	_tmp13_ = main_get_active_tab ((Main*) self);
	_tmp14_ = _tmp13_;
	if (g_strcmp0 (_tmp14_, "other") == 0) {
		GtkBuilder* _tmp15_;
		GObject* _tmp16_ = NULL;
		GtkWidget* _tmp17_;
		GtkWidget* ibar;
		GtkWidget* _tmp18_;
		GtkBuilder* _tmp19_;
		GObject* _tmp20_ = NULL;
		GtkWidget* _tmp21_;
		GtkWidget* _tmp22_;
		GtkBuilder* _tmp23_;
		GObject* _tmp24_ = NULL;
		GtkWidget* _tmp25_;
		GtkWidget* _tmp26_;
		_tmp15_ = ((Main*) self)->builder;
		_tmp16_ = gtk_builder_get_object (_tmp15_, "infbar_color");
		_tmp17_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp16_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp16_) : NULL);
		ibar = _tmp17_;
		_tmp18_ = ibar;
		gtk_widget_show (_tmp18_);
		_tmp19_ = ((Main*) self)->builder;
		_tmp20_ = gtk_builder_get_object (_tmp19_, "infbar_terminal");
		_tmp21_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp20_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp20_) : NULL);
		_g_object_unref0 (ibar);
		ibar = _tmp21_;
		_tmp22_ = ibar;
		gtk_widget_show (_tmp22_);
		_tmp23_ = ((Main*) self)->builder;
		_tmp24_ = gtk_builder_get_object (_tmp23_, "infbar_profiles");
		_tmp25_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp24_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp24_) : NULL);
		_g_object_unref0 (ibar);
		ibar = _tmp25_;
		_tmp26_ = ibar;
		gtk_widget_show (_tmp26_);
		_g_object_unref0 (ibar);
	} else {
		GtkBuilder* _tmp27_;
		const gchar* _tmp28_;
		const gchar* _tmp29_;
		gchar* _tmp30_;
		gchar* _tmp31_;
		GObject* _tmp32_ = NULL;
		GtkWidget* _tmp33_;
		GtkWidget* _tmp34_;
		GtkWidget* ibar;
		GtkWidget* _tmp35_;
		_tmp27_ = ((Main*) self)->builder;
		_tmp28_ = main_get_active_tab ((Main*) self);
		_tmp29_ = _tmp28_;
		_tmp30_ = g_strconcat ("infbar_", _tmp29_, NULL);
		_tmp31_ = _tmp30_;
		_tmp32_ = gtk_builder_get_object (_tmp27_, _tmp31_);
		_tmp33_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp32_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp32_) : NULL);
		_tmp34_ = _tmp33_;
		_g_free0 (_tmp31_);
		ibar = _tmp34_;
		_tmp35_ = ibar;
		gtk_widget_show (_tmp35_);
		_g_object_unref0 (ibar);
	}
	_g_object_unref0 (current_tab_infbar);
	_g_object_unref0 (infbar_f2theora);
}


static void ns_widgets_behaviour_class_init (NSWidgetsBehaviourClass * klass) {
	ns_widgets_behaviour_parent_class = g_type_class_peek_parent (klass);
}


static void ns_widgets_behaviour_instance_init (NSWidgetsBehaviour * self) {
}


GType ns_widgets_behaviour_get_type (void) {
	static volatile gsize ns_widgets_behaviour_type_id__volatile = 0;
	if (g_once_init_enter (&ns_widgets_behaviour_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NSWidgetsBehaviourClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ns_widgets_behaviour_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NSWidgetsBehaviour), 0, (GInstanceInitFunc) ns_widgets_behaviour_instance_init, NULL };
		GType ns_widgets_behaviour_type_id;
		ns_widgets_behaviour_type_id = g_type_register_static (TYPE_MAIN, "NSWidgetsBehaviour", &g_define_type_info, 0);
		g_once_init_leave (&ns_widgets_behaviour_type_id__volatile, ns_widgets_behaviour_type_id);
	}
	return ns_widgets_behaviour_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}




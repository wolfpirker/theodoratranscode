/* command.c generated by valac 0.18.1, the Vala compiler
 * generated from command.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#define NS_COMMAND_TYPE_CREATION (ns_command_creation_get_type ())
#define NS_COMMAND_CREATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), NS_COMMAND_TYPE_CREATION, NSCommandCreation))
#define NS_COMMAND_CREATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), NS_COMMAND_TYPE_CREATION, NSCommandCreationClass))
#define NS_COMMAND_IS_CREATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NS_COMMAND_TYPE_CREATION))
#define NS_COMMAND_IS_CREATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NS_COMMAND_TYPE_CREATION))
#define NS_COMMAND_CREATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), NS_COMMAND_TYPE_CREATION, NSCommandCreationClass))

typedef struct _NSCommandCreation NSCommandCreation;
typedef struct _NSCommandCreationClass NSCommandCreationClass;
typedef struct _NSCommandCreationPrivate NSCommandCreationPrivate;

#define NS_FILE_TYPE_LOADING (ns_file_loading_get_type ())
#define NS_FILE_LOADING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), NS_FILE_TYPE_LOADING, NSFileLoading))
#define NS_FILE_LOADING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), NS_FILE_TYPE_LOADING, NSFileLoadingClass))
#define NS_FILE_IS_LOADING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NS_FILE_TYPE_LOADING))
#define NS_FILE_IS_LOADING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NS_FILE_TYPE_LOADING))
#define NS_FILE_LOADING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), NS_FILE_TYPE_LOADING, NSFileLoadingClass))

typedef struct _NSFileLoading NSFileLoading;
typedef struct _NSFileLoadingClass NSFileLoadingClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

#define NS_COMMAND_TYPE_EXECUTION (ns_command_execution_get_type ())
#define NS_COMMAND_EXECUTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), NS_COMMAND_TYPE_EXECUTION, NSCommandExecution))
#define NS_COMMAND_EXECUTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), NS_COMMAND_TYPE_EXECUTION, NSCommandExecutionClass))
#define NS_COMMAND_IS_EXECUTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NS_COMMAND_TYPE_EXECUTION))
#define NS_COMMAND_IS_EXECUTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NS_COMMAND_TYPE_EXECUTION))
#define NS_COMMAND_EXECUTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), NS_COMMAND_TYPE_EXECUTION, NSCommandExecutionClass))

typedef struct _NSCommandExecution NSCommandExecution;
typedef struct _NSCommandExecutionClass NSCommandExecutionClass;
typedef struct _NSCommandExecutionPrivate NSCommandExecutionPrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _NSCommandCreation {
	GObject parent_instance;
	NSCommandCreationPrivate * priv;
};

struct _NSCommandCreationClass {
	GObjectClass parent_class;
};

struct _NSCommandCreationPrivate {
	gchar* _conversion_command;
	NSFileLoading* loading;
};

struct _Block1Data {
	int _ref_count_;
	NSCommandCreation * self;
	guint i;
	gchar* c_start;
	gchar** temp;
	gint temp_length1;
	gint _temp_size_;
	guint8 count;
};

struct _NSCommandExecution {
	GObject parent_instance;
	NSCommandExecutionPrivate * priv;
};

struct _NSCommandExecutionClass {
	GObjectClass parent_class;
};

struct _NSCommandExecutionPrivate {
	gchar* _info;
};


static gpointer ns_command_creation_parent_class = NULL;
static gpointer ns_command_execution_parent_class = NULL;

GType ns_command_creation_get_type (void) G_GNUC_CONST;
GType ns_file_loading_get_type (void) G_GNUC_CONST;
#define NS_COMMAND_CREATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NS_COMMAND_TYPE_CREATION, NSCommandCreationPrivate))
enum  {
	NS_COMMAND_CREATION_DUMMY_PROPERTY,
	NS_COMMAND_CREATION_CONVERSION_COMMAND
};
NSCommandCreation* ns_command_creation_new (void);
NSCommandCreation* ns_command_creation_construct (GType object_type);
#define MAIN_LAST_PROFILE "most recent"
NSFileLoading* ns_file_loading_new (const gchar* file);
NSFileLoading* ns_file_loading_construct (GType object_type, const gchar* file);
void ns_file_loading_create_valuelist (NSFileLoading* self, guint8 mode);
static void ns_command_creation_set_command (NSCommandCreation* self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
GList* ns_file_loading_get_valuelist (NSFileLoading* self);
static void __lambda4_ (Block1Data* _data1_, const gchar* val);
static void ___lambda4__gfunc (gconstpointer data, gpointer self);
const gchar* ns_command_creation_get_conversion_command (NSCommandCreation* self);
static void ns_command_creation_finalize (GObject* obj);
static void _vala_ns_command_creation_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
GType ns_command_execution_get_type (void) G_GNUC_CONST;
#define NS_COMMAND_EXECUTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NS_COMMAND_TYPE_EXECUTION, NSCommandExecutionPrivate))
enum  {
	NS_COMMAND_EXECUTION_DUMMY_PROPERTY,
	NS_COMMAND_EXECUTION_INFO
};
NSCommandExecution* ns_command_execution_new (void);
NSCommandExecution* ns_command_execution_construct (GType object_type);
gboolean ns_command_execution_sync_command (NSCommandExecution* self, const gchar* command);
gboolean ns_command_execution_async_command (NSCommandExecution* self, const gchar* command);
const gchar* ns_command_execution_get_info (NSCommandExecution* self);
static void ns_command_execution_finalize (GObject* obj);
static void _vala_ns_command_execution_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const gchar* NS_COMMAND_CREATION_aliases[30] = {"target_NOTUSEDHERE", "--subtitles-encoding", "--subtitles-language", "--nosubtitles", "*", "--starttime", "--endtime", "*-v*", "*-a*", "*-V*", "*-A*", "-y", "-F", "-x", "*", "*", "*", "--optimize", "--soft-target", "--two-pass", "--croptop", "--cropright", "--cropbottom", "--cropleft", "*", "*", "-C", "-B", "-G", "-Z"};

NSCommandCreation* ns_command_creation_construct (GType object_type) {
	NSCommandCreation * self = NULL;
	NSFileLoading* _tmp0_;
	NSFileLoading* _tmp1_;
	self = (NSCommandCreation*) g_object_new (object_type, NULL);
	_tmp0_ = ns_file_loading_new ("last_" MAIN_LAST_PROFILE ".json");
	_g_object_unref0 (self->priv->loading);
	self->priv->loading = _tmp0_;
	_tmp1_ = self->priv->loading;
	ns_file_loading_create_valuelist (_tmp1_, (guint8) 0);
	ns_command_creation_set_command (self);
	return self;
}


NSCommandCreation* ns_command_creation_new (void) {
	return ns_command_creation_construct (NS_COMMAND_TYPE_CREATION);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		NSCommandCreation * self;
		self = _data1_->self;
		_data1_->temp = (_vala_array_free (_data1_->temp, _data1_->temp_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_data1_->c_start);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void __lambda4_ (Block1Data* _data1_, const gchar* val) {
	NSCommandCreation * self;
	guint _tmp48_;
	self = _data1_->self;
	g_return_if_fail (val != NULL);
	switch (_data1_->i) {
		case 0:
		case 4:
		{
			break;
		}
		case 7:
		case 8:
		case 9:
		case 10:
		case 12:
		{
			const gchar* _tmp0_;
			gchar* _tmp1_;
			gchar* _tmp2_;
			guint8 _tmp3_;
			_tmp0_ = val;
			_tmp1_ = g_strdup (_tmp0_);
			_g_free0 (_data1_->temp[_data1_->count]);
			_data1_->temp[_data1_->count] = _tmp1_;
			_tmp2_ = _data1_->temp[_data1_->count];
			_tmp3_ = _data1_->count;
			_data1_->count = _tmp3_ + 1;
			break;
		}
		case 14:
		{
			const gchar* _tmp4_;
			_tmp4_ = val;
			if (g_strcmp0 (_tmp4_, "true") == 0) {
				const gchar* _tmp5_;
				gchar* _tmp6_;
				gchar* _tmp7_;
				gchar* _tmp8_;
				_tmp5_ = _data1_->temp[2];
				_tmp6_ = g_strconcat (" -V ", _tmp5_, NULL);
				_tmp7_ = _tmp6_;
				_tmp8_ = g_strconcat (_data1_->c_start, _tmp7_, NULL);
				_g_free0 (_data1_->c_start);
				_data1_->c_start = _tmp8_;
				_g_free0 (_tmp7_);
			} else {
				const gchar* _tmp9_;
				gchar* _tmp10_;
				gchar* _tmp11_;
				gchar* _tmp12_;
				_tmp9_ = _data1_->temp[0];
				_tmp10_ = g_strconcat (" -v ", _tmp9_, NULL);
				_tmp11_ = _tmp10_;
				_tmp12_ = g_strconcat (_data1_->c_start, _tmp11_, NULL);
				_g_free0 (_data1_->c_start);
				_data1_->c_start = _tmp12_;
				_g_free0 (_tmp11_);
			}
			break;
		}
		case 15:
		{
			const gchar* _tmp13_;
			_tmp13_ = val;
			if (g_strcmp0 (_tmp13_, "true") == 0) {
				const gchar* _tmp14_;
				gchar* _tmp15_;
				gchar* _tmp16_;
				gchar* _tmp17_;
				_tmp14_ = _data1_->temp[3];
				_tmp15_ = g_strconcat (" -A ", _tmp14_, NULL);
				_tmp16_ = _tmp15_;
				_tmp17_ = g_strconcat (_data1_->c_start, _tmp16_, NULL);
				_g_free0 (_data1_->c_start);
				_data1_->c_start = _tmp17_;
				_g_free0 (_tmp16_);
			} else {
				const gchar* _tmp18_;
				gchar* _tmp19_;
				gchar* _tmp20_;
				gchar* _tmp21_;
				_tmp18_ = _data1_->temp[1];
				_tmp19_ = g_strconcat (" -a ", _tmp18_, NULL);
				_tmp20_ = _tmp19_;
				_tmp21_ = g_strconcat (_data1_->c_start, _tmp20_, NULL);
				_g_free0 (_data1_->c_start);
				_data1_->c_start = _tmp21_;
				_g_free0 (_tmp20_);
			}
			break;
		}
		case 16:
		{
			const gchar* _tmp22_;
			gchar** _tmp27_ = NULL;
			_tmp22_ = val;
			if (g_strcmp0 (_tmp22_, "false") == 0) {
				const gchar* _tmp23_;
				gchar* _tmp24_;
				gchar* _tmp25_;
				gchar* _tmp26_;
				_tmp23_ = _data1_->temp[4];
				_tmp24_ = g_strconcat (" -F ", _tmp23_, NULL);
				_tmp25_ = _tmp24_;
				_tmp26_ = g_strconcat (_data1_->c_start, _tmp25_, NULL);
				_g_free0 (_data1_->c_start);
				_data1_->c_start = _tmp26_;
				_g_free0 (_tmp25_);
			}
			_tmp27_ = g_new0 (gchar*, 5 + 1);
			_data1_->temp = (_vala_array_free (_data1_->temp, _data1_->temp_length1, (GDestroyNotify) g_free), NULL);
			_data1_->temp = _tmp27_;
			_data1_->temp_length1 = 5;
			_data1_->_temp_size_ = _data1_->temp_length1;
			break;
		}
		case 24:
		{
			const gchar* _tmp28_;
			gchar* _tmp29_;
			gchar* _tmp30_;
			gchar* _tmp31_;
			_tmp28_ = val;
			_tmp29_ = g_strconcat (" ", _tmp28_, NULL);
			_tmp30_ = _tmp29_;
			_tmp31_ = g_strconcat (_data1_->c_start, _tmp30_, NULL);
			_g_free0 (_data1_->c_start);
			_data1_->c_start = _tmp31_;
			_g_free0 (_tmp30_);
			break;
		}
		case 25:
		{
			break;
		}
		default:
		{
			const gchar* _tmp32_;
			_tmp32_ = val;
			if (g_strcmp0 (_tmp32_, "true") == 0) {
				const gchar* _tmp33_;
				gchar* _tmp34_;
				gchar* _tmp35_;
				gchar* _tmp36_;
				_tmp33_ = NS_COMMAND_CREATION_aliases[_data1_->i];
				_tmp34_ = g_strconcat (" ", _tmp33_, NULL);
				_tmp35_ = _tmp34_;
				_tmp36_ = g_strconcat (_data1_->c_start, _tmp35_, NULL);
				_g_free0 (_data1_->c_start);
				_data1_->c_start = _tmp36_;
				_g_free0 (_tmp35_);
			} else {
				const gchar* _tmp37_;
				_tmp37_ = val;
				if (g_strcmp0 (_tmp37_, "false") == 0) {
				} else {
					const gchar* _tmp38_;
					_tmp38_ = val;
					if (g_strcmp0 (_tmp38_, "") == 0) {
					} else {
						const gchar* _tmp39_;
						gchar* _tmp40_;
						gchar* _tmp41_;
						gchar* _tmp42_;
						gchar* _tmp43_;
						const gchar* _tmp44_;
						gchar* _tmp45_;
						gchar* _tmp46_;
						gchar* _tmp47_;
						_tmp39_ = NS_COMMAND_CREATION_aliases[_data1_->i];
						_tmp40_ = g_strconcat (" ", _tmp39_, NULL);
						_tmp41_ = _tmp40_;
						_tmp42_ = g_strconcat (_tmp41_, " ", NULL);
						_tmp43_ = _tmp42_;
						_tmp44_ = val;
						_tmp45_ = g_strconcat (_tmp43_, _tmp44_, NULL);
						_tmp46_ = _tmp45_;
						_tmp47_ = g_strconcat (_data1_->c_start, _tmp46_, NULL);
						_g_free0 (_data1_->c_start);
						_data1_->c_start = _tmp47_;
						_g_free0 (_tmp46_);
						_g_free0 (_tmp43_);
						_g_free0 (_tmp41_);
					}
				}
			}
			break;
		}
	}
	_tmp48_ = _data1_->i;
	_data1_->i = _tmp48_ + 1;
}


static void ___lambda4__gfunc (gconstpointer data, gpointer self) {
	__lambda4_ (self, data);
}


static void ns_command_creation_set_command (NSCommandCreation* self) {
	Block1Data* _data1_;
	gchar* _tmp0_;
	gchar** _tmp1_ = NULL;
	NSFileLoading* _tmp2_;
	GList* _tmp3_;
	GList* _tmp4_;
	gchar* _tmp5_;
	g_return_if_fail (self != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_data1_->i = (guint) 0;
	_tmp0_ = g_strdup ("ffmpeg2theora");
	_data1_->c_start = _tmp0_;
	_tmp1_ = g_new0 (gchar*, 5 + 1);
	_data1_->temp = _tmp1_;
	_data1_->temp_length1 = 5;
	_data1_->_temp_size_ = _data1_->temp_length1;
	_data1_->count = (guint8) 0;
	_tmp2_ = self->priv->loading;
	_tmp3_ = ns_file_loading_get_valuelist (_tmp2_);
	_tmp4_ = _tmp3_;
	g_list_foreach (_tmp4_, ___lambda4__gfunc, _data1_);
	_tmp5_ = g_strdup (_data1_->c_start);
	_g_free0 (self->priv->_conversion_command);
	self->priv->_conversion_command = _tmp5_;
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


const gchar* ns_command_creation_get_conversion_command (NSCommandCreation* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_conversion_command;
	result = _tmp0_;
	return result;
}


static void ns_command_creation_class_init (NSCommandCreationClass * klass) {
	ns_command_creation_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (NSCommandCreationPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_ns_command_creation_get_property;
	G_OBJECT_CLASS (klass)->finalize = ns_command_creation_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), NS_COMMAND_CREATION_CONVERSION_COMMAND, g_param_spec_string ("conversion-command", "conversion-command", "conversion-command", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void ns_command_creation_instance_init (NSCommandCreation * self) {
	self->priv = NS_COMMAND_CREATION_GET_PRIVATE (self);
}


static void ns_command_creation_finalize (GObject* obj) {
	NSCommandCreation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, NS_COMMAND_TYPE_CREATION, NSCommandCreation);
	_g_free0 (self->priv->_conversion_command);
	_g_object_unref0 (self->priv->loading);
	G_OBJECT_CLASS (ns_command_creation_parent_class)->finalize (obj);
}


GType ns_command_creation_get_type (void) {
	static volatile gsize ns_command_creation_type_id__volatile = 0;
	if (g_once_init_enter (&ns_command_creation_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NSCommandCreationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ns_command_creation_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NSCommandCreation), 0, (GInstanceInitFunc) ns_command_creation_instance_init, NULL };
		GType ns_command_creation_type_id;
		ns_command_creation_type_id = g_type_register_static (G_TYPE_OBJECT, "NSCommandCreation", &g_define_type_info, 0);
		g_once_init_leave (&ns_command_creation_type_id__volatile, ns_command_creation_type_id);
	}
	return ns_command_creation_type_id__volatile;
}


static void _vala_ns_command_creation_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	NSCommandCreation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, NS_COMMAND_TYPE_CREATION, NSCommandCreation);
	switch (property_id) {
		case NS_COMMAND_CREATION_CONVERSION_COMMAND:
		g_value_set_string (value, ns_command_creation_get_conversion_command (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


NSCommandExecution* ns_command_execution_construct (GType object_type) {
	NSCommandExecution * self = NULL;
	self = (NSCommandExecution*) g_object_new (object_type, NULL);
	return self;
}


NSCommandExecution* ns_command_execution_new (void) {
	return ns_command_execution_construct (NS_COMMAND_TYPE_EXECUTION);
}


gboolean ns_command_execution_sync_command (NSCommandExecution* self, const gchar* command) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (command != NULL, FALSE);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		_tmp0_ = command;
		g_spawn_command_line_sync (_tmp0_, &_tmp1_, NULL, NULL, &_inner_error_);
		_g_free0 (self->priv->_info);
		self->priv->_info = _tmp1_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_SPAWN_ERROR) {
				goto __catch1_g_spawn_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	goto __finally1;
	__catch1_g_spawn_error:
	{
		GError* e = NULL;
		FILE* _tmp2_;
		GError* _tmp3_;
		const gchar* _tmp4_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = stdout;
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		fprintf (_tmp2_, "Error: %s\n", _tmp4_);
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


gboolean ns_command_execution_async_command (NSCommandExecution* self, const gchar* command) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (command != NULL, FALSE);
	{
		const gchar* _tmp0_;
		_tmp0_ = command;
		g_spawn_command_line_async (_tmp0_, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_SPAWN_ERROR) {
				goto __catch2_g_spawn_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	goto __finally2;
	__catch2_g_spawn_error:
	{
		GError* e = NULL;
		FILE* _tmp1_;
		GError* _tmp2_;
		const gchar* _tmp3_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp1_ = stdout;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		fprintf (_tmp1_, "Error: %s\n", _tmp3_);
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


const gchar* ns_command_execution_get_info (NSCommandExecution* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_info;
	result = _tmp0_;
	return result;
}


static void ns_command_execution_class_init (NSCommandExecutionClass * klass) {
	ns_command_execution_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (NSCommandExecutionPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_ns_command_execution_get_property;
	G_OBJECT_CLASS (klass)->finalize = ns_command_execution_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), NS_COMMAND_EXECUTION_INFO, g_param_spec_string ("info", "info", "info", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void ns_command_execution_instance_init (NSCommandExecution * self) {
	self->priv = NS_COMMAND_EXECUTION_GET_PRIVATE (self);
}


static void ns_command_execution_finalize (GObject* obj) {
	NSCommandExecution * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, NS_COMMAND_TYPE_EXECUTION, NSCommandExecution);
	_g_free0 (self->priv->_info);
	G_OBJECT_CLASS (ns_command_execution_parent_class)->finalize (obj);
}


GType ns_command_execution_get_type (void) {
	static volatile gsize ns_command_execution_type_id__volatile = 0;
	if (g_once_init_enter (&ns_command_execution_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NSCommandExecutionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ns_command_execution_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NSCommandExecution), 0, (GInstanceInitFunc) ns_command_execution_instance_init, NULL };
		GType ns_command_execution_type_id;
		ns_command_execution_type_id = g_type_register_static (G_TYPE_OBJECT, "NSCommandExecution", &g_define_type_info, 0);
		g_once_init_leave (&ns_command_execution_type_id__volatile, ns_command_execution_type_id);
	}
	return ns_command_execution_type_id__volatile;
}


static void _vala_ns_command_execution_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	NSCommandExecution * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, NS_COMMAND_TYPE_EXECUTION, NSCommandExecution);
	switch (property_id) {
		case NS_COMMAND_EXECUTION_INFO:
		g_value_set_string (value, ns_command_execution_get_info (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



